from numpy import *;
import numpy as np; 

#x=[87,11,22,48,16,54,13,36,81,48,11,44,70,0,43,68,92,75,91,17,3,15,5,21,18,4,42,75,77,25,81,73,42,39,37,73,48,3,83,93,67,57,59,45,29,43,41,95,9,15,50,36,57,9,75,45,80,54,58,36,82,47,58,98,29,86,17,85,53,81,75,44,61,84,54,47,26,64,60,11,76,71,13,100,43,26,19,69,32,4,84,91,24,38,11,100,83,76,31,40,80]

#y=[274,46,90,161,68,178,41,125,261,156,42,143,220,1,130,217,285,231,282,59,10,46,23,75,67,15,130,234,240,76,248,241,136,135,135,243,152,20,254,298,223,173,181,147,94,149,131,287,47,61,170,130,181,32,232,148,252,169,181,120,263,144,185,309,105,277,73,257,167,255,236,147,206,260,183,142,91,193,192,50,230,214,43,315,145,96,57,222,120,12,267,286,75,124,38,323,267,248,111,126,260]

x=[0.198,0.287,0.312,0.333,0.51]
y=[3.3,3,2.9,3.5,2.98]

def lwlr(testPoint, xArr, yArr, k = 1.0):
    xMat = mat(xArr); yMat = mat(yArr).T
    m = shape(xMat)[0]
    weights = mat(eye((m)))
    for i in range(m):
        diffMat = testPoint - xMat[i, :]
        weights[i, i] = exp(diffMat * diffMat.T/(-2.0 * k**2))      # 计算权重对角矩阵
    xTx = xMat.T * (weights * xMat)                                 # 奇异矩阵不能计算
    if linalg.det(xTx) == 0.0:
        print('This Matrix is singular, cannot do inverse')
        return
    theta = xTx.I * (xMat.T * (weights * yMat))                     # 计算回归系数
    return testPoint * theta



print(lwlr(10,x,y,10000000))






