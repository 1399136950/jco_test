当可以在文本字符串中回退时，如果从右向左扫描模式字符串并将它和文本串匹配，那么就能得到一种非常快的字符串查找算法——Boyer-Moore算法。
事实上，BM（Boyer-Moore）算法是目前被认为最高效的字符串搜索算法， 一般情况下，比KMP算法快3-5倍，它由Bob Boyer和J Strother Moore设计于1977年。该算法常用于文本编辑器中的搜索匹配功能，比如GNU grep命令使用的就是该算法。


同样是文本回退，相对于BF算法，BM算法的优势在于当不匹配的时候一次性可以跳过不止一个字符。即它不需要对被搜索的字符串中的字符进行逐一比较，而会跳过其中某些部分。
通常搜索关键字越长，算法速度越快。它的效率来自于这样的事实：对于每一次失败的匹配尝试，算法都能够使用这些信息来排除尽可能多的无法匹配的位置。即它充分利用待搜索字符串的一些特征，加快了搜索的步骤。


要实现启发式地处理不匹配的字符，我们需要记录下模式串中每一种字符在模式串中出现的最靠右的位置。
这个值揭示了如果该字符出现在文本中且在查找时造成了一次匹配失败，模式串应该向右移动（跳跃）多远。

 

记录好模式串的相关信息后，BM算法的实现就很简单了。我们依然用指针i在文本串中从左向右移动，但模式串的指针则是从右向左移动。
内循环会检查正文和模式字符串在位置i是否一致，如果从M-1到0的所有j，str[i+j]=pat[j]，则匹配成功。否则匹配失败，会遇到以下两种情况：

 （1）如果造成匹配失败的文本串字符不包含在模式串中，说明在当前情况下肯定无法匹配整个模式串，因此将模式串向右移动j+1个位置（即i += j+1）。

 （2）如果造成匹配失败的文本串字符包含在模式串中，则找到这个字符在模式串中最靠右的位置，对齐模式串和文本串，使得该字符和它在模式串中出现的最右位置相匹配。
